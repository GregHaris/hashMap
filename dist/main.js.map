{"version":3,"file":"main.js","mappings":"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","sources":["webpack://hash-map-project/./src/index.js","webpack://hash-map-project/./src/hashmap.js","webpack://hash-map-project/./src/hashSet.js"],"sourcesContent":["import HashMap from './hashmap';\nimport Hashset from './hashSet';\n\nconst test = new HashMap();\nconst test2 = new Hashset();\n\ntest.set('apple', 'red');\ntest.set('banana', 'yellow');\ntest.set('carrot', 'orange');\ntest.set('dog', 'brown');\ntest.set('elephant', 'gray');\ntest.set('frog', 'green');\ntest.set('grape', 'purple');\ntest.set('hat', 'black');\ntest.set('ice cream', 'white');\ntest.set('jacket', 'blue');\ntest.set('kite', 'pink');\ntest.set('lion', 'golden');\ntest.set('moon', 'silver');\n\ntest2.add('apple', 'red');\ntest2.add('banana', 'yellow');\ntest2.add('carrot', 'orange');\ntest2.add('dog', 'brown');\ntest2.add('elephant', 'gray');\ntest2.add('frog', 'green');\ntest2.add('grape', 'purple');\ntest2.add('hat', 'black');\ntest2.add('ice cream', 'white');\ntest2.add('jacket', 'blue');\ntest2.add('kite', 'pink');\ntest2.add('lion', 'golden');\ntest2.add('moon', 'silver');\n\nconsole.table(test.entries());\nconsole.log(test2);\n","export default class HashMap {\n  constructor(size = 50) {\n    this.buckets = new Array(size);\n    this.size = 0;\n  }\n\n  // hash function\n  hash(key) {\n    let hashCode = 0;\n    let i = 0;\n\n    const primeNumber = 31;\n    while (i < key.length) {\n      hashCode =\n        (primeNumber * hashCode + key.charCodeAt(i)) % this.buckets.length;\n      i++;\n    }\n    return hashCode;\n  }\n\n  // add key values to buckets\n  set(key, value) {\n    let index = this.hash(key);\n    let i = 0;\n\n    //  if hashed bucket index doesn't exit, create it\n    if (!this.buckets[index]) {\n      this.buckets[index] = [];\n    }\n\n    // check if there is collission. If true, replace the old with new\n    while (i < this.buckets[index].length) {\n      if (this.buckets[index][i][0] === key) {\n        this.buckets[index][i][1] = value;\n        return;\n      }\n      i++;\n    }\n\n    // if false, add to the map\n    this.buckets[index].push([key, value]);\n    this.size++;\n  }\n\n  get(key) {\n    let index = this.hash(key);\n\n    if (!this.buckets[index]) {\n      return null;\n    }\n\n    for (let bucket of this.buckets[index]) {\n      if (bucket[0] === key) {\n        return bucket[1];\n      }\n    }\n    return null;\n  }\n\n  // check if key exists in the map\n  has(key) {\n    let index = this.hash(key);\n\n    if (!this.buckets[index]) {\n      return false;\n    }\n\n    // if it does, then return true\n    for (let bucket of this.buckets[index]) {\n      if (bucket[0] === key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  //  delete a hash element\n  remove(key) {\n    let index = this.hash(key);\n    let i = 0;\n\n    if (!this.buckets[index]) {\n      return `Key '${key}' not found`;\n    }\n\n    // if it does, delete then return true\n    while (i < this.buckets[index].length) {\n      if (this.buckets[index][i][0] === key) {\n        this.buckets[index].splice(i, 1);\n\n        this.size--;\n\n        return `key '${key}' and its hashes has been successfully deleted`;\n      }\n      i++;\n    }\n\n    return `Key '${key}' not found`;\n  }\n\n  // get the number of keys in the hash map\n  length() {\n    return this.size;\n  }\n\n  // clear the map\n  clear() {\n    this.buckets = new Array(this.buckets.length);\n    this.size = 0;\n  }\n\n  // get an array of all keys in hash map\n  keys() {\n    let keys = [];\n    let allBucketsEmpty = true;\n\n    for (let i = 0; i < this.buckets.length; i++) {\n      if (this.buckets[i]) {\n        allBucketsEmpty = false;\n        for (let bucket of this.buckets[i]) {\n          keys.push(bucket[0]);\n        }\n      }\n    }\n\n    if (allBucketsEmpty) {\n      return 'All Hash map bucket are empty';\n    }\n\n    return keys;\n  }\n\n  // get an array of all values in hash map\n  values() {\n    let values = [];\n    let allBucketsEmpty = true;\n\n    for (let i = 0; i < this.buckets.length; i++) {\n      if (this.buckets[i]) {\n        allBucketsEmpty = false;\n        for (let bucket of this.buckets[i]) {\n          values.push(bucket[1]);\n        }\n      }\n    }\n\n    if (allBucketsEmpty) {\n      return 'All Hash map bucket are empty';\n    }\n\n    return values;\n  }\n\n  // get an array of all key-value pairs in hash map\n  entries() {\n    let entries = [];\n    let allBucketsEmpty = true;\n\n    for (let i = 0; i < this.buckets.length; i++) {\n      if (this.buckets[i]) {\n        allBucketsEmpty = false;\n        for (let bucket of this.buckets[i]) {\n          entries.push(bucket);\n        }\n      }\n    }\n\n    if (allBucketsEmpty) {\n      return 'All Hashmap bucket are empty';\n    }\n\n    return entries;\n  }\n}\n","export default class Hashset {\n  constructor(size = 50) {\n    this.buckets = new Array(size);\n    this.size = 0;\n  }\n\n  // hash function\n  hash(key) {\n    let hashCode = 0;\n    let i = 0;\n\n    const primeNumber = 31;\n    while (i < key.length) {\n      hashCode =\n        (primeNumber * hashCode + key.charCodeAt(i)) % this.buckets.length;\n      i++;\n    }\n    return hashCode;\n  }\n\n  // add key values to buckets\n  add(key) {\n    let index = this.hash(key);\n    let i = 0;\n\n    //  if hashed bucket index doesn't exit, create it\n    if (!this.buckets[index]) {\n      this.buckets[index] = [];\n    }\n\n    // check if there is collission. If true, replace the old with new\n    while (i < this.buckets[index].length) {\n      if (this.buckets[index][i] === key) {\n        this.buckets[index] = key;\n        return;\n      }\n      i++;\n    }\n\n    // if false, add to the map\n    this.buckets[index].push(key);\n    this.size++;\n  }\n\n  // check if key exists in the map\n  has(key) {\n    let index = this.hash(key);\n\n    if (!this.buckets[index]) {\n      return false;\n    }\n\n    // if it does, then return true\n    for (let bucket of this.buckets[index]) {\n      if (bucket[0] === key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  //  delete a hash element\n  remove(key) {\n    let index = this.hash(key);\n    let i = 0;\n\n    if (!this.buckets[index]) {\n      return `Key '${key}' not found`;\n    }\n\n    // if it does, delete then return true\n    while (i < this.buckets[index].length) {\n      if (this.buckets[index][i][0] === key) {\n        this.buckets[index].splice(i, 1);\n\n        this.size--;\n\n        return `key '${key}' and its hashes has been successfully deleted`;\n      }\n      i++;\n    }\n\n    return `Key '${key}' not found`;\n  }\n\n  // get the number of keys in the hash map\n  length() {\n    return this.size;\n  }\n\n  // clear the map\n  clear() {\n    this.buckets = new Array(this.buckets.length);\n    this.size = 0;\n  }\n\n  // get an array of all keys in hash map\n  keys() {\n    let keys = [];\n    let allBucketsEmpty = true;\n\n    for (let i = 0; i < this.buckets.length; i++) {\n      if (this.buckets[i]) {\n        allBucketsEmpty = false;\n        for (let bucket of this.buckets[i]) {\n          keys.push(bucket);\n        }\n      }\n    }\n\n    if (allBucketsEmpty) {\n      return 'All Hash map bucket are empty';\n    }\n\n    return keys;\n  }\n}\n"],"names":["test","constructor","size","this","buckets","Array","hash","key","hashCode","i","length","charCodeAt","set","value","index","push","get","bucket","has","remove","splice","clear","keys","allBucketsEmpty","values","entries","test2","add","console","table","log"],"sourceRoot":""}